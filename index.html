<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cinematic Galaxy</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; }
</style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152/examples/js/postprocessing/UnrealBloomPass.js"></script>

<script>
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  5000
);
camera.position.set(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// === POST PROCESSING BLOOM ===
const composer = new THREE.EffectComposer(renderer);
composer.addPass(new THREE.RenderPass(scene, camera));

const bloomPass = new THREE.UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  1.5,
  0.4,
  0.85
);
composer.addPass(bloomPass);

// === GALAXY SPHERE ===
const textureLoader = new THREE.TextureLoader();
const galaxyTexture = textureLoader.load("your-image.png");

const sphereGeometry = new THREE.SphereGeometry(1500, 128, 128);
const sphereMaterial = new THREE.MeshBasicMaterial({
  map: galaxyTexture,
  side: THREE.BackSide
});
const galaxySphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(galaxySphere);

// === BLACK HOLE CORE ===
const coreGeometry = new THREE.SphereGeometry(80, 64, 64);
const coreMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
const core = new THREE.Mesh(coreGeometry, coreMaterial);
core.position.set(0, 0, -400);
scene.add(core);

// === NEBULA FOG ===
const fogGeometry = new THREE.SphereGeometry(1400, 64, 64);
const fogMaterial = new THREE.MeshBasicMaterial({
  color: 0x331144,
  transparent: true,
  opacity: 0.08,
  side: THREE.BackSide
});
const fog = new THREE.Mesh(fogGeometry, fogMaterial);
scene.add(fog);

// === SPACE DUST ===
const dustGeometry = new THREE.BufferGeometry();
const dustCount = 4000;
const positions = new Float32Array(dustCount * 3);

for (let i = 0; i < dustCount * 3; i++) {
  positions[i] = (Math.random() - 0.5) * 3000;
}

dustGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

const dustMaterial = new THREE.PointsMaterial({
  color: 0xffffff,
  size: 2,
  transparent: true,
  opacity: 0.8
});

const dust = new THREE.Points(dustGeometry, dustMaterial);
scene.add(dust);

// === SHOOTING STARS ===
function createMeteor() {
  const geometry = new THREE.CylinderGeometry(0.5, 0.5, 100, 8);
  const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const meteor = new THREE.Mesh(geometry, material);

  meteor.rotation.z = Math.PI / 4;
  meteor.position.set(
    (Math.random() - 0.5) * 1000,
    (Math.random() - 0.5) * 1000,
    -800
  );

  scene.add(meteor);

  function animateMeteor() {
    meteor.position.x += 25;
    meteor.position.y -= 25;
    meteor.position.z += 25;

    if (meteor.position.z > 800) {
      scene.remove(meteor);
    } else {
      requestAnimationFrame(animateMeteor);
    }
  }

  animateMeteor();
}

setInterval(createMeteor, 3500);

// === CAMERA CONTROL ===
let mouseX = 0;
let mouseY = 0;

document.addEventListener("mousemove", (e) => {
  mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
  mouseY = (e.clientY / window.innerHeight - 0.5) * 2;
});

// === WARP MODE ===
let warp = false;
document.addEventListener("click", () => warp = !warp);

let speed = 0.5;

function animate() {
  requestAnimationFrame(animate);

  // Spiral galaxy rotation
  galaxySphere.rotation.y += 0.0005;
  fog.rotation.y += 0.0003;

  // Mouse camera drift
  camera.rotation.y += (mouseX * 0.05 - camera.rotation.y) * 0.05;
  camera.rotation.x += (mouseY * 0.05 - camera.rotation.x) * 0.05;

  // Forward movement
  if (warp) {
    speed = 8;
    dustMaterial.size = 6;
    bloomPass.strength = 2.5;
  } else {
    speed = 0.5;
    dustMaterial.size = 2;
    bloomPass.strength = 1.5;
  }

  camera.position.z -= speed;

  if (camera.position.z < -1400) {
    camera.position.z = 0;
  }

  composer.render();
}

animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
  </html>
